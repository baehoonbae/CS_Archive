디스크가 “랜덤 바이트 단위”로는 느리고 비싸지만, “블록(페이지) 단위”로는 빠르고 싸기 때문

## ① 디스크의 물리적 특성

- HDD/SSD/NVMe 다 **블록 장치**
- 최소 읽기/쓰기 단위 = 4KB 블록(페이지).
- 100바이트만 바꿔도 → 디스크는 4KB 블록을 읽고, 수정하고, 4KB를 다시 쓴다.

> 결론: 바이트 단위 랜덤 쓰기는 존재하지 않음 → 어차피 페이지 단위로 I/O 해야함
> 
> 
> 바이트 단위 랜덤 쓰기란 “파일의 임의 위치에 딱 몇 바이트만 덮어쓰기”를 의미.
> 디스크는 **실제로 바이트 단위로 못 쓰고 블록(페이지) 단위로만 쓴다.**
> 
> - HDD든 SSD든 디스크 컨트롤러는 **쓰기 명령을 최소 블록 단위**로 수행
> - 보통 4KB 블록
> - → 1바이트만 바꿔도 실제로는 **4KB를 읽고 → 수정하고 → 4KB를 다시 씀**
> - 따라서 디스크는 1바이트만 덮어쓰라고 해도 4KB 쓰기 I/O를 발생시킴

---

## ② 효율적인 I/O

- 페이지 단위 I/O → 연속적인 큰 읽기/쓰기 가능
- 디스크는 순차 읽기가 랜덤보다 훨씬 빠름
- DBMS가 페이지로 묶어서 I/O 스케줄링 → 디스크 대역폭을 극대화

> 결론: 페이지 단위 없으면 디스크 성능 활용 못 함.
> 

---

## ③ 버퍼풀(메모리 캐시) 설계 가능

- 메모리 ↔ 디스크의 단위가 같아야 캐싱이 단순
- 페이지 단위로 메모리에 로드
- 페이지 교체 알고리즘(LRU 등) 적용 가능

> 결론: 페이지 단위가 없으면 캐시 설계가 지옥이 됨.
> 

---

## ④ 업데이트와 트랜잭션

- 단일 레코드 덮어쓰기 → 페이지 읽고 → 메모리 수정 → 페이지 단위 다시 쓰기
- Write-Ahead Logging(WAL) → 페이지 단위 Redo/Undo
- Atomic flush = 페이지 단위 쓰기

> 결론: 페이지 단위가 없으면 Update/Delete가 안전하게 구현 불가능.
> 

---

## ⑤ 인덱스 트리 구조

- B+Tree, LSM Tree → 노드 단위가 페이지
- 페이지 크기에 맞춰 노드 split/merge
- 페이지 단위 I/O로 노드 읽기/쓰기

> 결론: 페이지 단위가 없으면 인덱스 설계 자체가 불가능.
> 

---

## ⑥ 공간 관리

- Free Space 관리
- 페이지 안에서 record slot 관리
- 압축, fragmentation 감소
- Variable-length record 지원

> 결론: 페이지 단위 설계 없으면 DBMS가 storage layout을 최적화할 수 없음.
>